\begin{minted}{ts}
export function compileDirective(
    outputCtx: OutputContext,
directive: CompileDirectiveMetadata,
reflector: CompileReflector) {

  const definitionMapValues:
{key: string, quoted: boolean, value: o.Expression}[] = [];

  // e.g. 'type: MyDirective`
  definitionMapValues.push(
      {key: 'type',
value: outputCtx.importExpr(directive.type.reference),
quoted: false});

  // e.g. `factory: () => new MyApp(injectElementRef())`
1 const templateFactory =
createFactory(directive.type, outputCtx, reflector);
2 definitionMapValues.push(
{key: 'factory', value: templateFactory, quoted: false});

  // e.g 'inputs: {a: 'a'}`
  if (Object.getOwnPropertyNames(directive.inputs).length > 0) {
    definitionMapValues.push(
        {key: 'inputs',
quoted: false,
value: mapToExpression(directive.inputs)});
  }

  const className = identifierName(directive.type) !;
  className || error(`Cannot resolver the name of ${directive.type}`);

  // Create the partial class to be merged with the actual class.
3 outputCtx.statements.push( 4 new o.ClassStmt(
      /* name */ className,
      /* parent */ null,
      /* fields */[new o.ClassField(
          /* name */ 'ngDirectiveDef',
          /* type */ o.INFERRED_TYPE,
          /* modifiers */[o.StmtModifier.Static],
          /* initializer */ 5 o.importExpr(R3.defineDirective).callFn(
[o.literalMap(definitionMapValues)]))],
      /* getters */[],
      /* constructorMethod */ new o.ClassMethod(null, [], []),
      /* methods */[]));
}
\end{minted}
